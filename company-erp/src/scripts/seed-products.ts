import { NestFactory } from '@nestjs/core';
import { AppModule } from '../app.module';
import { GetObjectCommand, ListObjectsV2Command } from '@aws-sdk/client-s3';
import { ProductsService } from '../modules/products/products.service';
import { s3Client } from '../modules/minio/s3.config';
import { getArg, getArgNumber, pickOne, randInt } from './seed-utils';

async function streamToBuffer(body: any): Promise<Buffer> {
  // AWS SDK v3: Body can be a Node.js Readable
  if (Buffer.isBuffer(body)) return body;
  if (!body) return Buffer.alloc(0);
  const chunks: Buffer[] = [];
  for await (const chunk of body as AsyncIterable<Buffer | string>) {
    chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
  }
  return Buffer.concat(chunks);
}

function mimeFromKey(key: string) {
  const lower = key.toLowerCase();
  if (lower.endsWith('.png')) return 'image/png';
  if (lower.endsWith('.jpg') || lower.endsWith('.jpeg')) return 'image/jpeg';
  if (lower.endsWith('.webp')) return 'image/webp';
  return 'application/octet-stream';
}

async function main() {
  const count = getArgNumber('count', 100);
  const start = getArgNumber('start', Date.now());
  const withImagesFromBucket = getArg('withImagesFromBucket', 'false') === 'true';

  const app = await NestFactory.createApplicationContext(AppModule, {
    logger: ['log', 'warn', 'error'],
  });

  try {
    const productsService = app.get(ProductsService);

    let imagePool:
      | { buffer: Buffer; originalname: string; mimetype: string }[]
      | undefined;

    if (withImagesFromBucket) {
      const bucket = process.env.MINIO_BUCKET ?? 'products';

      const listed = await s3Client.send(
        new ListObjectsV2Command({
          Bucket: bucket,
          MaxKeys: 50,
        }),
      );

      const keys =
        (listed.Contents ?? [])
          .map((o) => o.Key)
          .filter((k): k is string => !!k)
          // ignore folders
          .filter((k) => !k.endsWith('/')) ?? [];

      if (keys.length < 2) {
        throw new Error(
          `MinIO bucket "${bucket}" has <2 objects. Upload 2 images first, then rerun with --withImagesFromBucket=true.`,
        );
      }

      // Take first 2 objects (user said there are 2 images)
      const baseKeys = keys.slice(0, 2);

      imagePool = [];
      for (const key of baseKeys) {
        const obj = await s3Client.send(
          new GetObjectCommand({ Bucket: bucket, Key: key }),
        );
        const buffer = await streamToBuffer(obj.Body);
        imagePool.push({
          buffer,
          originalname: key.split('/').pop() || 'seed-image',
          mimetype: mimeFromKey(key),
        });
      }

      console.log(
        `Using ${imagePool.length} base images from MinIO bucket "${bucket}": ${baseKeys.join(
          ', ',
        )}`,
      );
    }

    let created = 0;
    for (let i = 0; i < count; i++) {
      const sku = `SKU-${start}-${i}`;
      const name = `Seed Product ${i + 1}`;
      const stock = randInt(0, 200);
      const price = Number((randInt(100, 50000) / 100).toFixed(2));

      let file: Express.Multer.File | undefined;
      if (imagePool) {
        const img = pickOne(imagePool);
        // Duplicate the base image per product (keeps image lifecycle tied to product)
        file = {
          originalname: img.originalname,
          mimetype: img.mimetype,
          size: img.buffer.length,
          buffer: img.buffer,
        } as any;
      }

      if (file) {
        await productsService.create(
          {
            sku,
            name,
            description: `Seeded product generated by script (${sku})`,
            stock,
            price,
          },
          file,
        );
      } else {
        await productsService.create({
          sku,
          name,
          description: `Seeded product generated by script (${sku})`,
          stock,
          price,
        });
      }

      created++;
      if (created % 25 === 0) console.log(`Created ${created}/${count} products...`);
    }

    console.log(`Done. Created ${created} products.`);
  } finally {
    await app.close();
  }
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
